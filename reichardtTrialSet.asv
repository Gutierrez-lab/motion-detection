
% This will allow you to run any type of subunit with any type of input
% noise (e.g. correlated or uncorrelated) and get a readout about motion in
% that stimulus input (in terms of probability). This readout is a vector
% called probLeft (what's the likelihood that motion was leftward) and is
% its mean and standard deviation is in the vector called probLeftSummary.

function [leftBool, rightBool] = ...
    reichardtTrialSet(params, stimLeftward, stimRightward)

% Generate responses
respLeftward = generateReichardtResp(params.model, stimLeftward, ...
    params.subunitType, params.subunitInh, params.subDelay, ...
    params.sampleIntrv, params.productSubtraction);
respRightward = generateReichardtResp(params.model, stimRightward, ...
    params.subunitType, params.subunitInh, params.subDelay, ...
    params.sampleIntrv, params.productSubtraction);

% [leftTemp, ~, leftSamp] = splitTrainTest(respLeftward, ...
%     params.sizeTrain);
% [rightTemp, ~, rightSamp] = splitTrainTest(respRightward, ...
%     params.sizeTrain);

leftSamp = respLeftward;
rightSamp = respRightward;

% Trim away the response portions at the beginning and end that are
% just to noise (e.g. no motion stimuli)
% Might want to just shorten the stimuli
respTStart = round(params.respTStart / params.sampleIntrv); 
respTEnd = round(params.respTEnd / params.sampleIntrv);
% leftTemp = leftTemp(1, respTStart:respTEnd);
% rightTemp = rightTemp(1, respTStart:respTEnd);
leftSamp = leftSamp(:, respTStart:respTEnd);
rightSamp = rightSamp(:, respTStart:respTEnd);

% This is where we would usually have a discriminant vector projection.
% But now we will try to do it WITHOUT the discriminant, by
% setting up a binary decision for motion direction based on the sign of 
% the integrated response.
% To quickly estimate the integral, we'll use the Trapezoid Rule (ie.,
% averaging the left and right Riemann sums)


leftBool = leftSamp; 
rightBool = rightSamp; 

    

end